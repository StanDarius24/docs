This documentation presents a solution to the problem raised by the validation of JWTs

To start with I will offer some code context to make it easier to explain.

```java
public class IntTest {

	public static String VALID_I3_TOKEN = "..."; // JWT token

	@Test  
	@DisplayName("Passing I3 Token To Get Car Items With XENTRYDT.XENTRY_WIS Entitlement Results in OK [200]")  
	public void passingI3TokenToGetCarItemsWithWisEntitlementResultsInOk() {  
		executeRestCall(CALL_PATH, VALID_I3_TOKEN, HttpStatus.OK);  
	}
}
```

The purpose of these tests is to check if a certain token is valid, if a certain token contains certain claims (entitlements), and so on.

I dont think it makes sense to describe how OAuth2 works here because there are many materials already all over the internet and I will only repeat myself. But it is still worth mentioning certain aspects that are also tested here in the code.

https://www.oauth.com -> for those who are curious

To generate a JWT we need a private and a public key. There are several options but what is necessary is for the private key to be stored on the server side, the same thing does not apply for the public one, and I can give you as example this case, where in int-tests the public one are sent as a mock.

Validation of a JWT signature according to its type is done with the public key.

In this case, our class calls a Rest method by attaching the token and the authorization field generated by us and at the same time, it sends the public key as a mock.

```json
{  
	"keys": [  
		{  
			"kty": "RSA",  
			"e": "AQAB",  
			"use": "sig",  
			"kid": "A8100PMUMpDg4ncAFZEZcjYAgn3IUhYU4rjAkEZi10M",  
			"alg": "RS256",  
			"n": "jePxNz5WcxtocE6ab-P6C_ye3G01W6LZZLZ_9HQ6Se2BM8GuDOhHDli6OTtvHqgtEMPGuYfeR1C5iERyTRyGkN8R938jrAVeG0x3mJ7dHwNp0unloK8nlSGtWsef1BswSNoP8Hlgnh_vx6x00o_Vg9cbgO3_54W6_b2liLsXVTdCyv5R0UcV3llYKHyBbZwGNpxMNpmla7Q2Wx86yDlezKjcsX5PJJmsmD9wh9ZfvmKPO-zHBKV6deUR-ndHN4LT8zCgW_g4w2QGgfUdHJ0RREJqZg0jBj_8rRh-hvyhii7zUK62c_ompEXQl11oaQskdUaX04Cj4SLXcJ3s6Er5QQ"  
		}  
	]  
}
```
as an example, this is how a public key looks like.

In order to continue using the same token that was defined at the beginning, it is impossible to change its content because in order to generate a new JWT we need the private key as well.

So in other words in my example I generated a set of new keys that I used further. 
Opinions were divided, but a very good question was, what will happen at runtime considering that at runtime there are other JWTs generated completely and completely different from the ones I will generate myself for int-tests.

First of all, the foundations of web security are based on the idea that a token that is not valid means that it was changed and not using its initial key set, and if we want to validate it based on oauth2 specification, the introspection endpoint will be called, from where it will take the public key. In our case, we have to modify the application settings and add :
```yaml
 security:  
	jwt:  
		validator:  
			jwks-url: http://tex-service.genesis-platform-tasp.svc.cluster.local/JWKS  
			expected-issuer: tex.genesis-platform-tasp  
			expected-audience: XENTRY-BACKENDS  
			allowedClockSkew: 60
```

---

Example:

First we need a key pair, and for that we can use this website
https://mkjwk.org
and with the proper configuration, key size = default in our case,
Key use = signature, algorithm = RSA256, key id = SHA-256,
we can generate a new key set and should look like this:

```json
{
    "keys": [
        {
            "p": "wVAy1Hh-qiVIAfG3XCP9S-QHreWIb_1jDVVSZHoLiwyOCPHfhvyDw1GVub6AVUa6yK8b-dOAJSXK5QyyrvN9j1cgqb0B9M616PVJFQB0soaKJpvSPDe5Rng7to2zrSnCeRht_EreCP_TMMSsnQUEhMa4sSl5joBr8at9PXyQ-O0",
            "kty": "RSA",
            "q": "wMmhXRu8I0wiktVunkBoE0gC4AgJrf6MBSgLeTdzf_vSHVIMaNVfqDPxdxWZVdLsttK3uDyxzU6QBn9s3z4boVANd68wu8-JxOpEXhueCkX1txJcLWqabDhoAPZdqjCrxe_2g66dDn8j0sXJJG9pG5IQ8i1a8JW5F9PmfTCveo8",
            "d": "HnczRWGVlFvXD4DFzvMCulRzS6D7gZEysvydRsZzWOZiZ7tQP1NzNEHCGLlxfLkpc20ZoCrNKjbkVr_xHwIkolb_OJS9MkrND4dufz14F5ZKQVPRnUmGT835u8aeyApfB8VGB8TTAo-itnUi_V1Xnd5n8YZl5qrdMy10UhqFiLAIYIurB9W4X7qYXAbIvwsWEJdi5wUVwIrRxYH18qFnLqicr-dyuXFGoKZMgpBhh07uD9zgWw2R7K1FahzWkUMNloIDiOo69UYlqqoAt7wumvI57wrBwgql5m1obL6P7eQWHQ9Ml7k7lSYnRTt4J8yTBZSzXp0ZE5H_fkweRdLLOQ",
            "e": "AQAB",
            "use": "sig",
            "kid": "Mq_ipNhESL7_hZIEH4pxZsybulrATd3IzQD93mpvNYM",
            "qi": "hCWb0ODLj1AaM0553bE1nIazPAHLRQqv__RTnCk_1W57UD7VTxnZ1dY-YSIc0y4AqizhMxxMJh-ihnn3-i_oby3J98GS4K_BaqhTrQ92LCD4yyspw0i65_codg80QNjLJopGsbBCEVCHZKlvMQzapxlMuAeDtWceHWUfbejJt1Q",
            "dp": "bnHmiJPLMmSYblvueZsqRWijpovEVs96_wwnRbagz7G9mIiwP8wXb8k19OhNI-uEHdJF9ocK6K5d7F1D3UbKDtIlnDSbYIWVUuKI_ZHEGpdZaNOP2s2vcf6RhywQYrfAHzWA6SrRDm0y-OL1B8TtHvr2XGmoxGzEv09N_4oivcU",
            "alg": "RS256",
            "dq": "jV7N_3LpIZEhAT-VoGJmb00tHo-GWZsBnn5g-4CYJ8_HokyaYP2m6bc9aC_kgzTq9J3Mr0OCtqTXpIwokAQBSudjGNLVD8P-qPGJNOFXoPzwVFEYWw2DM7yhN6Nxx-1s6PcwdBvFe-3rnRIAj8FK-DbCSnTL7QQ9-KUgrcjXxS0",
            "n": "kZRn8QI9OPAt58TRIBB1BYdDZz7Br31FPAjjyOTObjJ_FAXl4UVHPdHwjcaptiuuVHQx5fztJd-ubJotHTK1QL6RjBXVr3nkwRZOVXNvUsCNZ3cflZbnl2cejRT403dsp9j8J9k6K2Qgvco7g_3HR2WOeVVY9kCLIoZrxHjfTTfAfhCDZnAnKKNh7O4unZWkrVQII9Ajk62Pvhzq-cbA0a5nC39tGhsep6XJawKnwNUy19_oMUTyxsSR1BpXfIi5Xv4V-rACTwPMbOubRfnOdX7bEnwmydmMcgWY1ROcwsDl414XUQBCMQfbrZpF5JXY-z-pCb_ddD1loxI1RZ7-Yw"
        }
    ]
} // we dont use this in our code, dont worry :D
```

in out int-test we only need to provide:
- kty
- e
- use
- kid
- alg
- n // this is the public key

*to decrypt JWT you can use this official site*: https://jwt.io

Then if we try to decrypt the old JWT we can see it's context and in our case the JWT contains the following entitlement `RETACC.XENTRY_WIS`, remember that our test should return a 200 and should contain `XENTRYDT.XENTRY_WIS`.
So for that we need to modify the token so basically we need to generate a new one
https://www.scottbrady91.com/tools/jwt

In this site you can provide the new set of keys and you can define its payload based of what we decrypt using jwt.io, the result should be enough to pass the test.